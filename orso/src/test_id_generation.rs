#[cfg(test)]
mod id_generation_tests {
    use crate as orso;
    use orso::{Orso, Database, DatabaseConfig, Migrations, migration, Utils};
    use serde::{Deserialize, Serialize};

    #[derive(Orso, Serialize, Deserialize, Clone, Debug, Default)]
    #[orso_table("id_generation_test")]
    struct IdGenerationTest {
        #[orso_column(primary_key)]
        id: Option<String>,
        name: String,
        age: i32,
    }

    #[tokio::test]
    async fn test_id_auto_generation() -> Result<(), Box<dyn std::error::Error>> {
        // Create in-memory database
        let config = DatabaseConfig::memory();
        let db = Database::init(config).await?;

        // Create table
        Migrations::init(&db, &[migration!(IdGenerationTest)]).await?;

        // Create record with None ID (should auto-generate)
        let record = IdGenerationTest {
            id: None, // This should be auto-generated by the database
            name: "Test User".to_string(),
            age: 25,
        };

        // Insert record
        record.insert(&db).await?;

        // Retrieve all records
        let all_records = IdGenerationTest::find_all(&db).await?;
        assert_eq!(all_records.len(), 1);
        
        let retrieved = &all_records[0];
        assert!(retrieved.id.is_some(), "ID should be auto-generated");
        assert!(!retrieved.id.as_ref().unwrap().is_empty(), "ID should not be empty");
        assert_eq!(retrieved.name, "Test User");
        assert_eq!(retrieved.age, 25);

        Ok(())
    }

    #[tokio::test]
    async fn test_id_generation_debug() -> Result<(), Box<dyn std::error::Error>> {
        // Create in-memory database
        let config = DatabaseConfig::memory();
        let db = Database::init(config).await?;

        // Create table
        Migrations::init(&db, &[migration!(IdGenerationTest)]).await?;

        // Let's check the table schema to see what DEFAULT is set
        let schema_sql = "SELECT sql FROM sqlite_master WHERE type='table' AND name='id_generation_test'";
        let mut rows = db.conn.query(schema_sql, ()).await?;
        
        if let Some(row) = rows.next().await? {
            let schema: String = row.get(0)?;
            println!("Table schema: {}", schema);
        }

        // Create record with None ID
        let record = IdGenerationTest {
            id: None,
            name: "Debug Test".to_string(),
            age: 30,
        };

        // Insert record
        record.insert(&db).await?;

        // Check what was actually inserted
        let all_records = IdGenerationTest::find_all(&db).await?;
        println!("Records found: {}", all_records.len());
        
        for record in &all_records {
            println!("Record ID: {:?}", record.id);
            println!("Record name: {}", record.name);
            println!("Record age: {}", record.age);
        }

        assert_eq!(all_records.len(), 1);
        let retrieved = &all_records[0];
        assert!(retrieved.id.is_some(), "ID should be auto-generated");
        
        Ok(())
    }

    #[test]
    fn test_utils_generate_id() {
        let id1 = Utils::generate_id();
        let id2 = Utils::generate_id();
        
        // Both should be valid UUIDs
        assert!(!id1.is_empty());
        assert!(!id2.is_empty());
        
        // Should be different (very high probability)
        assert_ne!(id1, id2);
        
        // Should contain hyphens in correct positions for UUID format
        assert!(id1.contains('-'));
        assert_eq!(id1.len(), 36); // Standard UUID length
        
        // Should parse as valid UUID
        let uuid1 = uuid::Uuid::parse_str(&id1);
        assert!(uuid1.is_ok());
    }

    #[test]
    fn test_utils_current_timestamp() {
        let timestamp = Utils::current_timestamp();
        
        // Should not be empty
        assert!(!timestamp.is_empty());
        
        // Should contain T and end with Z
        assert!(timestamp.contains('T'));
        assert!(timestamp.ends_with('Z'));
        
        // Should parse back correctly
        let parsed = Utils::parse_timestamp(&timestamp);
        assert!(parsed.is_ok());
    }

    #[test]
    fn test_utils_parse_timestamp() {
        // Test valid timestamp
        let valid_timestamp = "2025-09-20T13:12:26.845448Z";
        let parsed = Utils::parse_timestamp(valid_timestamp);
        assert!(parsed.is_ok());
        
        // Test invalid timestamp
        let invalid_timestamp = "invalid-timestamp";
        let parsed = Utils::parse_timestamp(invalid_timestamp);
        assert!(parsed.is_err());
    }
}